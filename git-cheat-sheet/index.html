<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-PQ63V8S');</script>
<!-- End Google Tag Manager -->

    


    <title>Git 使用手册 – Algony Tony – etvdyn</title>

        <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="Git 基本概念解释及命令查询手册" />
    <meta property="og:description" content="Git 基本概念解释及命令查询手册" />
    
    <meta name="author" content="Algony Tony" />

    
    <meta property="og:title" content="Git 使用手册" />
    <meta property="twitter:title" content="Git 使用手册" />
    

    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="/assets/css/main.css" />
    <link rel="alternate" type="application/rss+xml" title="Algony Tony - etvdyn" href="/feed.xml" />

    

    
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3291441471504209"
     crossorigin="anonymous"></script>


    <link type="application/atom+xml" rel="alternate" href="https://algony-tony.github.io/feed.xml" title="Algony Tony" />
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Git 使用手册 | Algony Tony</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="Git 使用手册" />
<meta property="og:locale" content="zh_CN" />
<meta name="description" content="Git 基本概念解释及命令查询手册" />
<meta property="og:description" content="Git 基本概念解释及命令查询手册" />
<link rel="canonical" href="https://algony-tony.github.io/git-cheat-sheet/" />
<meta property="og:url" content="https://algony-tony.github.io/git-cheat-sheet/" />
<meta property="og:site_name" content="Algony Tony" />
<meta property="og:image" content="https://algony-tony.github.io/assets/img/post/git-diff.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-01-30T00:00:00+08:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="https://algony-tony.github.io/assets/img/post/git-diff.png" />
<meta property="twitter:title" content="Git 使用手册" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-01-30T00:00:00+08:00","datePublished":"2022-01-30T00:00:00+08:00","description":"Git 基本概念解释及命令查询手册","headline":"Git 使用手册","image":"https://algony-tony.github.io/assets/img/post/git-diff.png","mainEntityOfPage":{"@type":"WebPage","@id":"https://algony-tony.github.io/git-cheat-sheet/"},"url":"https://algony-tony.github.io/git-cheat-sheet/"}</script>
<!-- End Jekyll SEO tag -->


  </head>

  <body>

    
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PQ63V8S"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->


    <header class="site-header">

    <div class="wrapper-header">
      <div class="header-left">
        <!-- <a href="/" class="site-avatar"><img src="/assets/img/sys/jekyll-logo.png" alt="avatar" /></a> -->

        <a class="site-info" href="/">
          <span class="site-name">Algony Tony</span>
          <span class="site-description">etvdyn</span>
        </a>

      </div>

      <nav class="header-right">
        
        <a href="/"  class="page-link"  >
          首页
        </a>
        
        <a href="/WebMap/"  class="page-link"  >
          导航
        </a>
        
        <a href="/tools/"  class="page-link"  >
          工具
        </a>
        
        <a href="/collections/"  class="page-link"  >
          归档
        </a>
        
      </nav>
    </div>

</header>


    <main class="default-content" aria-label="内容区">
  <div class="wrapper-content">

    <article class="post">
      <div class="left">
        <h1>Git 使用手册</h1>
        <div class="label">

          <div class="label-date">
            2022-01-30
          </div>

          <div class="label-category">
            <span >类别:</span>

<a class="category-link" href="https://algony-tony.github.io/category/#软件技术" title="Category: 软件技术">
  软件技术
</a>


          </div>

          <div class="label-tag">
            <span >标签:</span>

<a class="tag-link" href="https://algony-tony.github.io/tag/#git" title="Tag: git">
  git
</a>

          </div>

        </div>

        <div class="entry">
          <ul id="markdown-toc">
  <li><a href="#仓库操作" id="markdown-toc-仓库操作">仓库操作</a>    <ul>
      <li><a href="#配置-git-config" id="markdown-toc-配置-git-config">配置 git config</a></li>
      <li><a href="#同步操作" id="markdown-toc-同步操作">同步操作</a></li>
      <li><a href="#稀疏检出-sparse-checkout" id="markdown-toc-稀疏检出-sparse-checkout">稀疏检出 sparse checkout</a></li>
      <li><a href="#子模块-submodule" id="markdown-toc-子模块-submodule">子模块 submodule</a></li>
    </ul>
  </li>
  <li><a href="#分支-git-branch" id="markdown-toc-分支-git-branch">分支 git branch</a>    <ul>
      <li><a href="#同步分支" id="markdown-toc-同步分支">同步分支</a></li>
      <li><a href="#删除分支-delete" id="markdown-toc-删除分支-delete">删除分支 delete</a></li>
      <li><a href="#合并分支-merge" id="markdown-toc-合并分支-merge">合并分支 merge</a></li>
      <li><a href="#变基操作-rebase" id="markdown-toc-变基操作-rebase">变基操作 rebase</a></li>
      <li><a href="#merge-or-rebase" id="markdown-toc-merge-or-rebase">merge or rebase</a></li>
    </ul>
  </li>
  <li><a href="#提交-git-commit" id="markdown-toc-提交-git-commit">提交 git commit</a>    <ul>
      <li><a href="#提交描述" id="markdown-toc-提交描述">提交描述</a></li>
      <li><a href="#删除-git-rm" id="markdown-toc-删除-git-rm">删除 git rm</a></li>
      <li><a href="#暂存-git-stash" id="markdown-toc-暂存-git-stash">暂存 git stash</a></li>
      <li><a href="#标签-git-tag" id="markdown-toc-标签-git-tag">标签 git tag</a></li>
      <li><a href="#日志-git-log" id="markdown-toc-日志-git-log">日志 git log</a></li>
      <li><a href="#撤销提交-git-reset" id="markdown-toc-撤销提交-git-reset">撤销提交 git reset</a></li>
    </ul>
  </li>
  <li><a href="#其他命令" id="markdown-toc-其他命令">其他命令</a>    <ul>
      <li><a href="#底层命令" id="markdown-toc-底层命令">底层命令</a></li>
      <li><a href="#父引用的快捷写法" id="markdown-toc-父引用的快捷写法">父引用的快捷写法</a></li>
      <li><a href="#引用日志-git-reflog" id="markdown-toc-引用日志-git-reflog">引用日志 git reflog</a></li>
    </ul>
  </li>
  <li><a href="#git-原理简介" id="markdown-toc-git-原理简介">Git 原理简介</a>    <ul>
      <li><a href="#存储" id="markdown-toc-存储">存储</a></li>
      <li><a href="#暂存区" id="markdown-toc-暂存区">暂存区</a></li>
    </ul>
  </li>
  <li><a href="#实战操作" id="markdown-toc-实战操作">实战操作</a>    <ul>
      <li><a href="#如何把一些提交从一个-git-仓库拷贝到另一个-git-仓库中" id="markdown-toc-如何把一些提交从一个-git-仓库拷贝到另一个-git-仓库中">如何把一些提交从一个 Git 仓库拷贝到另一个 Git 仓库中</a></li>
      <li><a href="#如何合并提交" id="markdown-toc-如何合并提交">如何合并提交</a></li>
      <li><a href="#如何在仓库中删除某位作者的所有提交" id="markdown-toc-如何在仓库中删除某位作者的所有提交">如何在仓库中删除某位作者的所有提交</a></li>
    </ul>
  </li>
  <li><a href="#参考链接" id="markdown-toc-参考链接">参考链接</a></li>
</ul>

<p>Git 是一个快速高效并免费开源的分布式版本管理系统。</p>

<p>Linus Torvalds 原来使用 BitKeeper 做 Linux 的内核源码管理，2005 年因为中间出现了一些矛盾，团队不能再用 BK，
但是也不想回到没有 BK 辅助管理源码的混乱状态，于是 Linus 打算自己写个代码版本管理软件，用了一天时间让 git 可以完成基本工作，后续就用 git 管理上了 git 的源码，他一个人把 git 从无到有开发差不多只用了 10 天时间。</p>

<h2 id="仓库操作">仓库操作</h2>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1">git init <span class="c"># 本地初始化 git 仓库</span>
</div><div class="line-2">git init <span class="nt">--bare</span> project.git <span class="c"># 初始化裸版本库，裸版本库一般用 .git 扩展名，且没有工作目录</span>
</div><div class="line-3">git remote add origin <span class="o">[</span>url] <span class="c"># 配置本地仓库的远端仓库地址，名字叫 origin</span>
</div><div class="line-4">git clone <span class="o">[</span>url] <span class="c"># 将指定地址的仓库下载到本地</span>
</div><div class="line-5">git remote <span class="nt">-v</span> <span class="c"># 显示远端仓库及地址</span>
</div></code></pre></figure>

<h3 id="配置-git-config">配置 git config</h3>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1">git config <span class="nt">--global</span> user.name <span class="s2">"[name]"</span>
</div><div class="line-2">git config <span class="nt">--global</span> user.email <span class="s2">"[email address]"</span>
</div><div class="line-3">git config <span class="nt">--list</span> <span class="c"># 列出配置项</span>
</div><div class="line-4">git config <span class="nt">--global</span> color.ui auto <span class="c"># 使用 Git 命令行配色</span>
</div><div class="line-5">git config <span class="nt">--global</span> core.editor <span class="s2">"vim"</span> <span class="c"># 使用 vim 作为 git 的默认编辑器</span>
</div><div class="line-6">
</div><div class="line-7">git config http.proxy http://proxy.mycompany:80
</div><div class="line-8"><span class="c"># 取消设置用 unset</span>
</div><div class="line-9">git config <span class="nt">--unset</span> http.proxy
</div></code></pre></figure>

<h3 id="同步操作">同步操作</h3>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1">git fetch <span class="c"># 下载远端跟踪分支的所有历史</span>
</div><div class="line-2">git merge <span class="c"># 将远端跟踪分支合并到当前本地分支</span>
</div><div class="line-3">git pull <span class="c"># 使用来自对应远端分支的所有新提交更新你当前的本地工作分支。git pull 是 git fetch 和 git merge 的结合</span>
</div></code></pre></figure>

<p>设置推送的默认行为 <code class="language-plaintext highlighter-rouge">push.default</code> 的几个选项，<a href="https://git-scm.com/docs/git-config#Documentation/git-config.txt-pushdefault">参考链接</a>：</p>
<ul>
  <li>nothing：不做任何推送；</li>
  <li>matching：只推送两端同名分支，Git 2.0 之前的默认设置；</li>
  <li>upstream：只推送当前分支到它设置好的上游分支，tracking 是相同意义的旧用法；</li>
  <li>current：只推送当前分支到它的同名分支上；</li>
  <li>simple：Git 2.0 后的默认行为，只推送当前分支到它的上游同名分支上，等于 upstream + current；</li>
</ul>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1">git push <span class="c"># 不加任何参数的推送行为由 push.default 设置</span>
</div><div class="line-2">git config push.default <span class="c"># 查看 push 的默认行为</span>
</div><div class="line-3">git config push.default simple <span class="c"># 设置 push 的默认行为</span>
</div><div class="line-4">
</div><div class="line-5"><span class="c"># --all 会将路径 refs/heads 下的所有分支都推送</span>
</div><div class="line-6"><span class="c"># -u 是将推送成功的分支都加上上游跟踪引用</span>
</div><div class="line-7">git push <span class="nt">--all</span> <span class="nt">-u</span> <span class="c"># 将所有本地分支提交上传到远端</span>
</div><div class="line-8">git push <span class="o">[</span>remote-name] <span class="o">[</span>local-branch-name]:[remote-branch-name] <span class="c"># 将本地的分支推送到远端，如果分支名一样可以省略冒号及之后的内容</span>
</div></code></pre></figure>

<p>在本地的分支做了 reset 回退操作后，推到远端时需要加上 <code class="language-plaintext highlighter-rouge">-f</code> 选项，否则会提示本地分支落后远端。</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1">git checkout master
</div><div class="line-2">git reset <span class="nt">--hard</span> <span class="o">[</span>commit-id]
</div><div class="line-3">git push <span class="nt">-f</span> origin master
</div></code></pre></figure>

<h3 id="稀疏检出-sparse-checkout">稀疏检出 sparse checkout</h3>

<p>稀疏检出可以从仓库中检出部分文件到工作目录，而不是默认的检出所有文件。
使用稀疏检出后其他命令的行为也会有点不同，切换分支时不会更新指定的稀疏检出指定的文件夹外的内容。</p>

<p>如果仓库太大，稀疏检出可以只挑选需要的内容到工作目录即可，还有一种情况，在 Windows 中检出 git 库报错“error: invalid path …”，
因为文件系统命名规则的限制导致一些文件无法检出，此时也可以使用稀疏检出。<a href="https://git-scm.com/docs/git-sparse-checkout">git-sparse-checkout</a></p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1"><span class="c"># 设置稀疏检出</span>
</div><div class="line-2">git config core.sparseCheckout <span class="nb">true</span>
</div><div class="line-3">
</div><div class="line-4"><span class="c"># 稀疏检出的内容是配置在 .git/info/sparse-checkout 文件中</span>
</div><div class="line-5"><span class="c"># 可以直接编辑文件，语法和 .gitignore 一样，以 ! 开头的路径表示排除在稀疏检出中</span>
</div><div class="line-6"><span class="nb">echo</span> /path1/subpath <span class="o">&gt;&gt;</span> .git/info/sparse-checkout
</div><div class="line-7"><span class="nb">echo</span> <span class="o">!</span>/path1/subpath <span class="o">&gt;&gt;</span> .git/info/sparse-checkout
</div><div class="line-8"><span class="c"># 检出所有内容</span>
</div><div class="line-9"><span class="nb">echo</span> <span class="s1">'/*'</span> <span class="o">&gt;&gt;</span> .git/info/sparse-checkout
</div><div class="line-10">
</div><div class="line-11">git checkout <span class="o">[</span>branch-name]
</div></code></pre></figure>

<p>如果 Windows 检出有 invalid path 报错，可以通过设置关闭保护 <code class="language-plaintext highlighter-rouge">git config core.protectNTFS false</code>。</p>

<h3 id="子模块-submodule">子模块 submodule</h3>

<p>如果需要在项目里引入另一个独立的 git 库，这时候就可以用到子模块（submodule）。子模块允许你将一个 git 仓库作为另一个仓库的子目录。</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1"><span class="c"># 在当前路径下会创建和项目同名的子模块目录</span>
</div><div class="line-2">git submodule add https://github.com/chaconinc/DbConnector
</div><div class="line-3">
</div><div class="line-4"><span class="c"># 会发现在外部项目的顶层多了一个 .gitmodules 文件，以及刚才加入的子模块目录 DbConnector 等待提交</span>
</div><div class="line-5"><span class="c"># .gitmodules 文件保存了子模块项目的 URL 和本地目录之间的映射关系</span>
</div><div class="line-6">git status
</div><div class="line-7">
</div><div class="line-8"><span class="c"># 此时可以切换子模块的分支或者某个提交上再将变更提交，就可以锁定子模块的分支和版本</span>
</div><div class="line-9"><span class="nb">cd </span>DbConnector
</div><div class="line-10">git checkout <span class="nt">-b</span> dev_branch origin/dev_branch
</div><div class="line-11">
</div><div class="line-12">git add .gitmodules DbConnector
</div><div class="line-13">git commit <span class="nt">-m</span> <span class="s2">"add submodule DbConnector"</span>
</div></code></pre></figure>

<p>克隆包含子模块的项目</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1"><span class="c"># 1. 先克隆父项目，此时子模块文件夹内是空的</span>
</div><div class="line-2">git clone https://github.com/chaconinc/MainProject
</div><div class="line-3"><span class="c"># 2. 更新子模块项目</span>
</div><div class="line-4">git submodule init
</div><div class="line-5">git submodule update
</div><div class="line-6">
</div><div class="line-7"><span class="c"># 克隆父项目的时候加上参数 --recurse-submodules 一步到位</span>
</div><div class="line-8">git clone <span class="nt">--recurse-submodules</span> https://github.com/chaconinc/MainProject
</div></code></pre></figure>

<h2 id="分支-git-branch">分支 git branch</h2>

<p>下面是一些常用的分支操作相关命令。</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1">git branch <span class="o">[</span>branch-name] <span class="c"># 创建分支</span>
</div><div class="line-2">git branch <span class="nt">-a</span> <span class="c"># 查看本地及远端的所有分支</span>
</div><div class="line-3">git switch <span class="nt">-c</span> <span class="o">[</span>branch-name] <span class="c"># 切换分支</span>
</div><div class="line-4">git checkout <span class="o">[</span>branch-name] <span class="c"># 切换分支，同上命令</span>
</div><div class="line-5">git checkout <span class="nt">-b</span> <span class="o">[</span>branch-name] <span class="c"># 创建分支，并切换到新分支上</span>
</div><div class="line-6">git merge <span class="o">[</span>branch-name] <span class="c"># 将指定分支合并到当前分支</span>
</div><div class="line-7">git branch <span class="nt">-f</span> <span class="o">[</span>branch-name] <span class="o">[</span>commit-id] <span class="c"># 在指定的 commit 上建立分支（若 branch 已经存在就切过去）</span>
</div><div class="line-8">git branch <span class="nt">-d</span> <span class="o">[</span>branch-name] <span class="c"># 删除某个分支</span>
</div><div class="line-9">
</div><div class="line-10">git branch <span class="nt">-m</span> <span class="o">[</span>oldname] <span class="o">[</span>newname] <span class="c"># 重命名分支</span>
</div><div class="line-11">git branch <span class="nt">-m</span> <span class="o">[</span>newname] <span class="c"># 将当前分支重命名</span>
</div><div class="line-12"><span class="c"># 如果在 Windows 这种大小写不敏感的系统中，并且分支改名只是改了大小写字母，那要用大写 -M 参数，否则会报错分支已存在</span>
</div><div class="line-13">
</div><div class="line-14"><span class="c"># 在 git merge 后发现有冲突 conflict，可以修正冲突后再提交，也可以放弃 merge</span>
</div><div class="line-15">git merge <span class="nt">--abort</span>
</div></code></pre></figure>

<p>查看和设置分支的上游</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1"><span class="c"># 查看分支及其上游</span>
</div><div class="line-2">git branch <span class="nt">-vv</span>
</div><div class="line-3">
</div><div class="line-4"><span class="c"># 设置分支上游</span>
</div><div class="line-5">git branch <span class="o">[</span>branch-name] <span class="nt">-u</span> <span class="o">[</span>remote]/[remote-branch-name]
</div><div class="line-6">git branch master <span class="nt">-u</span> origin/master
</div><div class="line-7">
</div><div class="line-8"><span class="c"># 也可以在推送的时候指定上游</span>
</div><div class="line-9">git push <span class="nt">-u</span> origin <span class="o">[</span>remote-branch-name]
</div></code></pre></figure>

<h3 id="同步分支">同步分支</h3>

<p>新克隆一个仓库到本地时默认只会创建 remote 当前 HEAD 指向的分支到本地，如果要新创建一个跟踪远端的本地分支，比如 dev，可以使用下面命令：</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1"><span class="c"># 先拉取远端 dev 分支</span>
</div><div class="line-2">git fetch origin dev
</div><div class="line-3">
</div><div class="line-4"><span class="c"># 创建本地分支并 checkout</span>
</div><div class="line-5">git checkout <span class="nt">-b</span> dev origin/dev
</div><div class="line-6">
</div><div class="line-7"><span class="c"># 或者直接创建分支并拉取远端对应分支</span>
</div><div class="line-8">git fetch <span class="o">[</span>remote-name] <span class="o">[</span>remote-branch-name]:[local-branch-name] <span class="c"># 同步远端分支到本地指定分支，本地分支如果不存在会创建指定分支名的分支</span>
</div><div class="line-9">git fetch origin dev:dev
</div></code></pre></figure>

<h3 id="删除分支-delete">删除分支 delete</h3>

<p>主要涉及三种分支：</p>
<ul>
  <li>本地分支 X；</li>
  <li>远端（如 origin）分支 X；</li>
  <li>本地跟踪远端 X 的分支 origin/X；</li>
</ul>

<table>
  <tbody>
    <tr>
      <td>X  —  origin/X</td>
      <td>X</td>
    </tr>
    <tr>
      <td>local repo</td>
      <td>remote origin repo</td>
    </tr>
  </tbody>
</table>

<p>删除本地分支</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1"><span class="c"># -d 是 --delete 的别名</span>
</div><div class="line-2">git branch <span class="nt">-d</span> <span class="o">[</span>branch-name]
</div><div class="line-3"><span class="c"># -D 是 --delete --force 的别名</span>
</div><div class="line-4">git branch <span class="nt">-D</span> <span class="o">[</span>branch-name]
</div></code></pre></figure>

<p>删除远端分支，会同时删除本地跟踪远端的分支。如果远端分支已经被删除了执行此命令会直接删除本地跟踪分支。</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1">git push <span class="o">[</span>remote-name] <span class="nt">--delete</span> <span class="o">[</span>branch-name]
</div><div class="line-2"><span class="c"># 旧版本 git 的写法如下</span>
</div><div class="line-3">git push <span class="o">[</span>remote_name] :[branch_name]
</div><div class="line-4">
</div><div class="line-5"><span class="c"># 从所有远端拉取变化，本地自动删除远端已删除的分支和标签</span>
</div><div class="line-6">git fetch <span class="nt">--all</span> <span class="nt">--prune</span>
</div></code></pre></figure>

<p>单独删除本地跟踪远端的分支</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1"><span class="c"># -dr 是 --delete --remotes 的别名</span>
</div><div class="line-2">git branch <span class="nt">--delete</span> <span class="nt">--remotes</span> <span class="o">[</span>remote-name]/[branch-name]
</div><div class="line-3">
</div><div class="line-4"><span class="c"># 同步删除远端已经删除的分支</span>
</div><div class="line-5">git fetch <span class="o">[</span>remote-name] <span class="nt">--prune</span>
</div></code></pre></figure>

<h3 id="合并分支-merge">合并分支 merge</h3>

<p>整合不同的分支主要有两种方法：合并（merge）和变基（rebase）。</p>

<p><strong>快进合并（fast-forward）</strong>指的是合并操作中没有需要解决的分歧，这样在合并两者时只是简单的将指针向前推进（指针右移），对于是否使用快进有三个选项。</p>

<ol>
  <li>选项 merge –ff，也是 merge 的默认选项，能快进合并的时候会选择快进；</li>
  <li>选项 merge –no-ff，能快进合并的时候也不快进，会额外再创建一个合并提交；</li>
  <li>选项 merge –ff-only，能快进合并的时候会快进，无需合并操作的时候也会成功，其他情况都会拒绝合并并非 0 退出；</li>
</ol>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1">git checkout master
</div><div class="line-2">
</div><div class="line-3"><span class="c"># 不使用快进合并，会出现一个额外的“耳朵”</span>
</div><div class="line-4"><span class="c">#                           master</span>
</div><div class="line-5"><span class="c"># C0◄───C1◄───────────────────C5</span>
</div><div class="line-6"><span class="c">#       ▲                     │</span>
</div><div class="line-7"><span class="c">#       └────C2◄───C3◄───C4◄──┘</span>
</div><div class="line-8"><span class="c">#                            feature-branch</span>
</div><div class="line-9">git merge <span class="nt">--no-ff</span> feature-branch
</div><div class="line-10">
</div><div class="line-11"><span class="c"># 快进合并，指针右移</span>
</div><div class="line-12"><span class="c">#                      master</span>
</div><div class="line-13"><span class="c"># C0◄───C1◄──C2◄───C3◄───C4</span>
</div><div class="line-14"><span class="c">#            │-----------│</span>
</div><div class="line-15"><span class="c">#        feature branch commits</span>
</div><div class="line-16">git merge <span class="nt">--ff</span> feature-branch
</div><div class="line-17">git merge <span class="nt">--ff-only</span> feature-branch <span class="c"># 效果同上</span>
</div><div class="line-18">
</div><div class="line-19"><span class="c"># 无法快进合并，因为有 C5 提交的存在</span>
</div><div class="line-20"><span class="c">#                           master</span>
</div><div class="line-21"><span class="c"># C0◄───C1◄────────C5─────────C6</span>
</div><div class="line-22"><span class="c">#       ▲                     │</span>
</div><div class="line-23"><span class="c">#       └────C2◄───C3◄───C4◄──┘</span>
</div><div class="line-24"><span class="c">#                            feature-branch</span>
</div><div class="line-25">git merge <span class="nt">--ff</span> feature-branch
</div><div class="line-26">git merge <span class="nt">--no-ff</span> feature-branch <span class="c"># 效果同上</span>
</div></code></pre></figure>

<h3 id="变基操作-rebase">变基操作 rebase</h3>

<p><strong>变基（rebase）</strong>是将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。</p>

<blockquote>
  <p>一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 origin/master 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。</p>
</blockquote>

<blockquote>
  <p>奇妙的变基也并非完美无缺，要用它得遵守一条准则：</p>

  <p><strong>如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。</strong></p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">cherry-pick</code> 是挑选一个或几个提交选择性的变基。</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1">git checkout topic
</div><div class="line-2">
</div><div class="line-3"><span class="c"># 变基前</span>
</div><div class="line-4"><span class="c">#                     A---B---C topic</span>
</div><div class="line-5"><span class="c">#                    /</span>
</div><div class="line-6"><span class="c">#               D---E---F---G master</span>
</div><div class="line-7">
</div><div class="line-8">git rebase master
</div><div class="line-9">git rebase master topic <span class="c"># 效果同上</span>
</div><div class="line-10"><span class="c"># 变基后</span>
</div><div class="line-11"><span class="c">#                             A'--B'--C' topic</span>
</div><div class="line-12"><span class="c">#                            /</span>
</div><div class="line-13"><span class="c">#               D---E---F---G master</span>
</div><div class="line-14">
</div><div class="line-15">git cherry-pick G
</div><div class="line-16"><span class="c"># 在变基前的基础上做挑选</span>
</div><div class="line-17"><span class="c">#                     A---B---C---G' topic</span>
</div><div class="line-18"><span class="c">#                    /</span>
</div><div class="line-19"><span class="c">#               D---E---F---G master</span>
</div></code></pre></figure>

<p>可以新建一个和主分支没有任何关联的<strong>孤儿分支</strong>，比如可以拿来放文档，或者存放一些页面，比如 Github Pages 功能就是用的 gh-pages 孤儿分支。</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1">git checkout <span class="nt">--orphan</span> gh-pages <span class="c"># 创建孤儿分支 gh-pages，并切换到分支上</span>
</div></code></pre></figure>

<h3 id="merge-or-rebase">merge or rebase</h3>

<p>合并变更可以选择 merge 或者 rebase，开源社区对这两种方式有很多讨论，两种方式各有好处，rebase 使你的提交树很简洁，所有的提交都在一条直线上，但是它是通过修改提交历史来达到的，
比如提交 C2 被 rebase 合并到 C3 之后，看起来 C2 在 C3 之后，其实 C2 的提交时间是在 C3 之前的。Merge 会完整保留历史记录，但是会多出很多 merge 的节点，并且在分支变多后会变得看起来很乱。其实这两种方式可以综合起来使用，如 <a href="https://stackoverflow.com/questions/804115/when-do-you-use-git-rebase-instead-of-git-merge">Stackoverflow 这个问题</a>所说，如果是开发一个特性，最后合并进主分支可以使用 merger 操作来合并，如果是另一个开发者开发进行了一些不相干的更改，你可以基于自己的变更来 rebase。</p>

<h2 id="提交-git-commit">提交 git commit</h2>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1">git add <span class="o">[</span>path-to-file] <span class="c"># 将文件加入暂存区</span>
</div><div class="line-2">git status <span class="c"># 展示工作区的状态</span>
</div><div class="line-3">git status <span class="nt">--short</span> <span class="nt">--ignored</span> <span class="c"># 简明展示工作区的状态，包含显示已忽略文件</span>
</div></code></pre></figure>

<p>Git 对每次提交会保存两个人的名字和邮箱，一个是作者（author），作为这次变更的作者，另一个是提交人（committer）,提交记录的人。
一般情况下这两个身份都是同一人。</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1">git commit <span class="nt">-m</span> <span class="s2">"[descriptive message]"</span>
</div><div class="line-2">git commit <span class="nt">--author</span><span class="o">=</span><span class="s2">"Bruce Wayne &lt;wayne@example.com&gt;"</span> <span class="c"># 指定提交的作者</span>
</div></code></pre></figure>

<p>用 git diff 显示变更内容</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1">git diff <span class="o">[</span>path-to-file] <span class="c"># 显示工作目录和暂存区的差异</span>
</div><div class="line-2">git diff <span class="o">[</span>commit-id] <span class="o">[</span>path-to-file] <span class="c"># 显示工作目录和指定提交的差异</span>
</div><div class="line-3">git diff HEAD <span class="o">[</span>path-to-file] <span class="c"># 显示工作目录和当前分支的最新提交记录的差异</span>
</div><div class="line-4">git diff <span class="nt">--cached</span> <span class="o">[</span>commit-id] <span class="o">[</span>path-to-file] <span class="c"># 显示暂存区和指定提交的差异</span>
</div><div class="line-5">git diff <span class="nt">--staged</span> HEAD <span class="o">[</span>path-to-file] <span class="c"># 显示暂存区和当前分支的最新提交记录的差异，staged 和 cached 效果一样</span>
</div></code></pre></figure>

<p><img src="/assets/img/post/git-diff.png" alt="Git diff" title="git diff" /></p>

<h3 id="提交描述">提交描述</h3>

<p>提交的消息的写法从技术上没有限制，但是有一个最佳实践的<a href="https://www.conventionalcommits.org/zh-hans/">约定式提交</a>。</p>

<blockquote>
  <p>约定式提交规范是一种基于提交信息的轻量级约定。它提供了一组简单规则来创建清晰的提交历史；这有利于编写自动化工具。
通过在提交信息中描述功能、修复和破坏性变更，是这种惯例与 <a href="https://semver.org/lang/zh-CN/">SemVer</a> （语义化版本）互相对应。</p>
</blockquote>

<p>提交说明的结构如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;type&gt;[optional scope]: &lt;description&gt;

[optional body]

[optional footer(s)]
</code></pre></div></div>

<h3 id="删除-git-rm">删除 git rm</h3>

<p><code class="language-plaintext highlighter-rouge">.gitignore</code> 文件会忽略未追踪的文件和文件夹，对已经加入追踪的文件则不起作用，需要取消已经加入追踪的文件要用 <code class="language-plaintext highlighter-rouge">git rm</code>。</p>

<p><code class="language-plaintext highlighter-rouge">git rm</code> 用于从暂存区和 Git 工作目录中删除文件，类似于 <code class="language-plaintext highlighter-rouge">git add</code> 的逆操作。加入 <code class="language-plaintext highlighter-rouge">--cached</code> 参数则只删除暂存区的文件，保留工作目录文件不动。</p>

<p>下面的操作不会删除本地工作目录的文件，但是推送到远端后其他开发人员 <code class="language-plaintext highlighter-rouge">git pull</code> 会删除他们本地工作目录的相应文件。</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1"><span class="c"># 1. 将要取消追踪的文件或文件夹加入 .gitignore 文件</span>
</div><div class="line-2">
</div><div class="line-3"><span class="c"># 2. 删除单个文件或文件夹</span>
</div><div class="line-4">git <span class="nb">rm</span> <span class="nt">--cached</span> <span class="o">[</span>file-name]
</div><div class="line-5">git <span class="nb">rm</span> <span class="nt">--cached</span> <span class="nt">-r</span> <span class="o">[</span>dir-name]
</div><div class="line-6">
</div><div class="line-7"><span class="c"># 3. 提交变更</span>
</div><div class="line-8">git commit <span class="nt">-m</span> <span class="o">[</span>commit-message]
</div></code></pre></figure>

<h3 id="暂存-git-stash">暂存 git stash</h3>

<p>保存未提交变更到本地堆栈中，一般用于中断本地开发临时切换到其他分支，后续切换分支回来再恢复变更继续开发。</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1">git stash <span class="c"># 保存变更到本地堆栈中</span>
</div><div class="line-2">git stash save <span class="o">[</span>message] <span class="c"># 保存变更到堆栈并记录标记信息</span>
</div><div class="line-3">git stash list <span class="c"># 列出保存的记录</span>
</div><div class="line-4">git stash pop <span class="c"># 恢复最近一次入栈记录内容</span>
</div><div class="line-5">git stash apply <span class="s2">"stash@{n}"</span> <span class="c"># 恢复暂存列表中的第几次暂存，双引号可以避免在一些终端的吃掉大括号</span>
</div></code></pre></figure>

<p>放弃修改，从某次提交中恢复历史版本</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1">git checkout <span class="o">[</span>commit-id] <span class="nt">--</span> <span class="o">[</span>path-to-file1] <span class="o">[</span>path-to-file2]
</div></code></pre></figure>

<p>如果只想暂存指定文件有两种办法</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1"><span class="c"># 用 git stash push</span>
</div><div class="line-2">git stash push <span class="nt">-m</span> <span class="o">[</span>message] path/to/file
</div><div class="line-3">
</div><div class="line-4"><span class="c"># 用交互方式确认哪些需要加入 stash</span>
</div><div class="line-5"><span class="c"># 交互模式下会遍历文件询问是否需要加入 stash</span>
</div><div class="line-6">git stash <span class="nt">--patch</span>
</div><div class="line-7">git stash <span class="nt">-p</span> <span class="c"># 效果同上</span>
</div><div class="line-8"><span class="c"># Stash this hunk [y,n,q,a,d,j,J,g,/,e,?]?</span>
</div><div class="line-9"><span class="c"># ? 显示帮助；y 暂存此改动；n 不暂存此改动；q 从此处退出，后续改动都未暂存；a 暂存此改动，后续改动都暂存；</span>
</div></code></pre></figure>

<p>查看最近一次暂存了哪些文件的命令如下。</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1">git stash show
</div><div class="line-2">
</div><div class="line-3"><span class="c"># 打印出每个文件的变更内容需要加上 -p 参数</span>
</div><div class="line-4">git stash show <span class="nt">-p</span>
</div><div class="line-5">
</div><div class="line-6"><span class="c"># 打印某次暂存的内容</span>
</div><div class="line-7">git stash show <span class="nt">-p</span> <span class="s2">"stash@{2}"</span>
</div></code></pre></figure>

<h3 id="标签-git-tag">标签 git tag</h3>

<p>Git 有两种类型的标签，一个是轻量标签（lightweight tag，也叫 unannotated tag），一种是标注标签（annotated tag）,它们的区别就是标注标签加了一段注释信息，官方文档对这两个的用途解释如下。</p>

<blockquote>
  <p>Annotated tags are meant for release while lightweight tags are meant for private or temporary object labels.</p>
</blockquote>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1">git tag <span class="nt">-l</span> <span class="c"># 列出当前所有标签</span>
</div><div class="line-2">git tag <span class="o">[</span>tag-name] <span class="o">[</span>commit-id] <span class="c"># 把无标注标签打在指定的 commit 上</span>
</div><div class="line-3">git tag <span class="o">[</span>tag-name] <span class="o">[</span>commit-id] <span class="nt">-a</span> <span class="nt">-m</span> <span class="o">[</span>tag-annotation] <span class="c"># 把标注标签打在指定 commit 上，如果有多行标注就使用多个 -m， 或者不写 -m 会打开默认编辑器编辑</span>
</div><div class="line-4">git tag <span class="nt">-d</span> <span class="o">[</span>tag-name] <span class="c"># 删除指定标签</span>
</div></code></pre></figure>

<p>默认情况下，git push 命令并不会传送标签到远端仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1">git push <span class="o">[</span>remote-name] <span class="o">[</span>tag-name] <span class="c"># 推送标签到远端服务器上</span>
</div><div class="line-2">git push <span class="o">[</span>remote-name] <span class="nt">--tags</span> <span class="c"># 把不在远端服务器上的标签都推到那里</span>
</div></code></pre></figure>

<h3 id="日志-git-log">日志 git log</h3>
<p>命令行下显示 git log graph，记忆法是 “A Dog” = git log –<strong>a</strong>ll –<strong>d</strong>ecorate –<strong>o</strong>neline –<strong>g</strong>raph</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1">git log <span class="nt">--all</span> <span class="nt">--decorate</span> <span class="nt">--oneline</span> <span class="nt">--graph</span>
</div></code></pre></figure>

<p>下面是一些常用的 git log 命令。</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1">git log <span class="nt">-n</span> 3 <span class="c"># 只显示最近三次提交记录</span>
</div><div class="line-2">git log <span class="nt">--author</span><span class="o">=</span><span class="s2">"John Smith"</span> <span class="c"># 显示某个指定 author 的提交记录</span>
</div><div class="line-3">git log <span class="nt">--committer</span><span class="o">=</span><span class="s2">"John</span><span class="se">\|</span><span class="s2">Mary"</span> <span class="c"># 显示指定某几个 committer 的提交记录</span>
</div><div class="line-4">git log <span class="nt">--after</span><span class="o">=</span><span class="s2">"2019-3-2"</span> <span class="c"># 显示某天后的提交记录</span>
</div><div class="line-5">git log <span class="nt">--before</span><span class="o">=</span><span class="s2">"yesterday"</span> <span class="c"># 显示某天前的提交记录</span>
</div><div class="line-6">git log <span class="nt">--follow</span> <span class="o">[</span>path-to-file] <span class="c"># 显示某个文件的提交记录</span>
</div><div class="line-7">git log <span class="nt">--</span> <span class="o">[</span>path-to-file] <span class="c"># 显示某个文件的提交记录，为避免文件名和分支名等重名，任何在 -- 后的字符串都将被当作文件名，在其之前的选项被当作分支名或者其他选项。</span>
</div><div class="line-8">git log <span class="nt">--grep</span><span class="o">=</span><span class="s2">"feat:"</span> <span class="c"># 在提交记录中搜索关键词</span>
</div><div class="line-9">git log <span class="nt">--no-merges</span> <span class="c"># 不显示合并的提交记录</span>
</div><div class="line-10">git log <span class="nt">--merges</span> <span class="c"># 只显示合并的提交记录</span>
</div><div class="line-11">git log <span class="nt">--format</span><span class="o">=</span>fuller <span class="c"># 显示提交记录的 author 和 committer</span>
</div><div class="line-12">git log <span class="nt">--patch</span> <span class="c"># 显示提交内文件变化的具体内容</span>
</div><div class="line-13">git log <span class="nt">--stat</span> <span class="c"># 显示提交的文件及变化统计数据</span>
</div><div class="line-14">
</div><div class="line-15">git show <span class="o">[</span>commit-id] <span class="c"># 显示某个提交的具体内容</span>
</div></code></pre></figure>

<h3 id="撤销提交-git-reset">撤销提交 git reset</h3>

<p>官网这篇<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86">7.7 Git 工具 - 重置揭密</a>关于 reset 和 checkout 介绍很详细。</p>

<p>git reset 会根据不同的参数来重置不同的区域</p>

<ol>
  <li>移动 HEAD 分支到指定的 commit（若指定了参数 –soft，则到此停止）</li>
  <li>将指定的 commit 恢复到暂存区（若指定了参数 –mixed，则到此停止，也是 git reset 的默认参数）</li>
  <li>将指定的 commit 恢复到工作目录（若指定了参数 –hard，就一直执行到这第 3 步）</li>
</ol>

<p>若 reset 命令中指定了路径，会跳过上面第一步，直接恢复指定的文件或者目录。</p>

<p><code class="language-plaintext highlighter-rouge">git reset --hard [branch]</code> 和 <code class="language-plaintext highlighter-rouge">git checkout [branch]</code> 非常类似，有两点不同，第一是 checkout 对工作目录会更安全些，第二是 reset 是移动 HEAD 所指向分支的指向，而 checkout 是移动 HEAD 指向的分支。</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1">         HEAD    HEAD                    HEAD
</div><div class="line-2">           |       |                       |
</div><div class="line-3">           V       V                       V
</div><div class="line-4">master    dev    master    dev    master  dev
</div><div class="line-5">  |        |       |        |       |    /
</div><div class="line-6">  V        V       V        V       V  /
</div><div class="line-7">  C1 &lt;<span class="nt">---</span> C2       C1 &lt;<span class="nt">---</span> C2       C1 &lt;<span class="nt">---</span> C2
</div><div class="line-8">   初始状态         checkout 后       reset 后
</div></code></pre></figure>

<p>下面的表格整理出来各命令的相关影响区域。“HEAD” 一列中的 “REF” 表示该命令移动了 HEAD 指向的分支引用，而 “HEAD” 则表示只移动了 HEAD 自身。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left"> </th>
      <th style="text-align: center">HEAD</th>
      <th style="text-align: center">Index</th>
      <th style="text-align: center">WordDir</th>
      <th style="text-align: center">WD Safe?</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><strong>Commit Level</strong></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">reset --soft [commit]</code></td>
      <td style="text-align: center">REF</td>
      <td style="text-align: center">No</td>
      <td style="text-align: center">No</td>
      <td style="text-align: center">Yes</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">reset [commit]</code></td>
      <td style="text-align: center">REF</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">No</td>
      <td style="text-align: center">Yes</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">reset --hard [commit]</code></td>
      <td style="text-align: center">REF</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">No</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">checkout [commit]</code></td>
      <td style="text-align: center">HEAD</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">Yes</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Commit Level</strong></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">reset [commit] &lt;paths&gt;</code></td>
      <td style="text-align: center">No</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">No</td>
      <td style="text-align: center">Yes</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">checkout [commit] &lt;paths&gt;</code></td>
      <td style="text-align: center">No</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">No</td>
    </tr>
  </tbody>
</table>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1">git reset <span class="o">[</span>commit-id] <span class="c"># 撤销所有 [commit] 后的的提交，在本地保存更改</span>
</div><div class="line-2">git reset <span class="nt">--hard</span> <span class="o">[</span>commit-id] <span class="c"># 放弃所有历史，改回指定提交。</span>
</div></code></pre></figure>

<p>取消提交到暂存区的变更，不改变工作目录的变更</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1">git reset HEAD <span class="nt">--</span> <span class="o">[</span>path-to-file] <span class="c"># 取消暂存区某个文件的变更</span>
</div><div class="line-2">git reset HEAD <span class="nt">--</span> <span class="nb">.</span> <span class="c"># 取消当前文件夹下在暂存区的所有变更</span>
</div></code></pre></figure>

<h2 id="其他命令">其他命令</h2>

<h3 id="底层命令">底层命令</h3>

<p>Git 命令主要分为上层（瓷器 porcelain）命令和底层（管道 plumbing）命令。日常中使用较多的是上层命令，上层命令最早是通过脚本将底层命令拼接使用的。
底层命令会更稳定一些。</p>

<p>获取命令的帮助文档。</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1">git <span class="nb">help</span> <span class="o">[</span><span class="nb">command</span><span class="o">]</span>
</div></code></pre></figure>

<p>获取 git 版本号。</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1">git version
</div></code></pre></figure>

<p>Git 提供了一个 <code class="language-plaintext highlighter-rouge">git show</code> 命令来查看任意类型的对象，可以是某个提交的具体的信息及变更内容，或者是标签的具体信息，还可以用来显示目录（tree 对象）和文件内容（blob 对象）。</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1">git show HEAD^^ <span class="c"># 查看当前提交往前数第二次提交的具体信息和内容</span>
</div><div class="line-2">git show v0.1 <span class="c"># 查看标签</span>
</div><div class="line-3">git show <span class="o">[</span>tag-name]:src/rand.c <span class="c"># 查看指定标签版本下的文件内容</span>
</div><div class="line-4">git show <span class="o">[</span>commit-id]:src <span class="c"># 查看指定提交下的目录内容</span>
</div></code></pre></figure>

<p>查看引用的全名，包含 .git/refs 文件夹下的内容，本地和远端的 refs 以及 tags。</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1">git show-ref
</div></code></pre></figure>

<p>查看 git 对象命令。</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1">git cat-file <span class="nt">-p</span> <span class="o">[</span>git-hash-id] <span class="c"># 打印 git 对象内容</span>
</div><div class="line-2">git cat-file <span class="nt">-t</span> <span class="o">[</span>git-hash-id] <span class="c"># 显示 git 对象类型</span>
</div></code></pre></figure>

<p><a href="https://stackoverflow.com/questions/460297/git-finding-the-sha1-of-an-individual-file-in-the-index">查看文件的 git hash 值</a></p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1"><span class="c"># git 对文件做的 hash 值不完全等于文件的 SHA1 值</span>
</div><div class="line-2"><span class="c"># 假设 ${file} 变量指向我们操作的文件</span>
</div><div class="line-3">
</div><div class="line-4"><span class="c"># get the Git hash of the file in index</span>
</div><div class="line-5"><span class="c"># -s show file mode, hash and stage number</span>
</div><div class="line-6">git ls-files <span class="nt">-s</span> <span class="nv">$file</span>
</div><div class="line-7">
</div><div class="line-8"><span class="c"># get the Git hash of any file on your filesystem</span>
</div><div class="line-9">git hash-object <span class="nv">$file</span>
</div><div class="line-10">
</div><div class="line-11"><span class="c"># get the Git hash of any file on your filesystem and you don't have Git installed</span>
</div><div class="line-12"><span class="o">(</span><span class="nb">echo</span> <span class="nt">-ne</span> <span class="s2">"blob </span><span class="sb">`</span><span class="nb">wc</span> <span class="nt">-c</span> &lt; <span class="nv">$file</span><span class="sb">`</span><span class="se">\0</span><span class="s2">"</span><span class="p">;</span> <span class="nb">cat</span> <span class="nv">$file</span><span class="o">)</span> | <span class="nb">sha1sum</span>
</div><div class="line-13"><span class="c"># 此处就展示出了 git 的 hash 值是怎么计算出来的，主要是对 "blob SIZE\0CONTENT" 做的 sha1 sum</span>
</div><div class="line-14"><span class="c"># 其中 SIZE 是文件的 file size in bytes，CONTENT 是文件实际内容</span>
</div></code></pre></figure>

<h3 id="父引用的快捷写法">父引用的快捷写法</h3>

<p><img src="/assets/img/post/git-relative-ref.png" alt="&quot;父引用的快捷写法&quot;" title="git 父引用的快捷写法" /></p>

<p>在修订名后面紧接着输入 ^ 符号表示该修订的第一个父对象。例如，HEAD^ 代表 HEAD 的父对象（节点），即上一个提交。对于合并提交来说，会拥有多个父对象，为了查询多个父对象中的某一个，你需要在 ^ 字符后指定它的数字代号，使用 <code class="language-plaintext highlighter-rouge">^&lt;n&gt;</code> 意味着查看修订的第 n 个父对象。我们可以将 ^ 理解为 ^1 的快捷方式。</p>

<p>一个比较特殊的情况是，<code class="language-plaintext highlighter-rouge">^0</code> 指代的是该提交自身。它还可以用来获取提交中包含附注（签名）的标签指针，<code class="language-plaintext highlighter-rouge">git show v0.9</code> 会显示标签标注信息和提交的相关信息，而 <code class="language-plaintext highlighter-rouge">git show v0.9^0</code> 只会显示标签附着的提交的相关信息。</p>

<p>这种后缀语法还可以组合使用。用户可以使用 HEAD^^ 来指向 HEAD 的祖父对象，即 HEAD^ 的父对象。</p>

<p>除了输入 n 个 ^ 后缀，例如 ^^…^ 或 ^1^1…^1，用户还可以使用 <code class="language-plaintext highlighter-rouge">~&lt;n&gt;</code>。这样 ~ 和 ~1 是等价的，HEAD~ 和 HEAD^ 也是等价的。HEAD~2 代表其第一个父对象的第一个父对象，即祖父对象，和 HEAD^^ 是等价的。</p>

<h3 id="引用日志-git-reflog">引用日志 git reflog</h3>
<p>每次更新 HEAD 或者更新分支首部时，git 会将这些信息记录在引用日志（reflog）中，这是以一种本地的临时日志，命令 <code class="language-plaintext highlighter-rouge">git reflog</code> 的输出中会用 HEAD@{n} 来表示 HEAD 之前的第 n 个值。</p>

<p>如果是用分支名，如 master@{n}，它代表的是该分支之前的第 n 个值，@{n} 是个特例，它表示当前分支之前的第 n 个值。</p>

<h2 id="git-原理简介">Git 原理简介</h2>

<p>Git 是一个内容寻址文件系统。一个 git 对象对应一个 40 位的散列值。</p>

<blockquote>
  <p>Git is a content-addressable filesystem.</p>
</blockquote>

<blockquote>
  <p>It means that at the core of Git is a simple key-value data store.</p>
</blockquote>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1"><span class="c"># 用 hash-object 生成 'test content' 的散列值</span>
</div><div class="line-2"><span class="nv">$ </span><span class="nb">echo</span> <span class="s1">'test content'</span> | git hash-object <span class="nt">-w</span> <span class="nt">--stdin</span>
</div><div class="line-3">d670460b4b4aece5915caf5c68d12f560a9fe3e4
</div><div class="line-4">
</div><div class="line-5"><span class="c"># 从散列值中检索出内容</span>
</div><div class="line-6"><span class="nv">$ </span>git cat-file <span class="nt">-p</span> d670460b4b4aece5915caf5c68d12f560a9fe3e4
</div><div class="line-7"><span class="nb">test </span>content
</div></code></pre></figure>

<p>StackOverflow 上有关于 40 位散列值碰撞的<a href="https://stackoverflow.com/questions/10434326/hash-collision-in-git">讨论</a>。</p>

<blockquote>
  <p>40 位 16 进制的散列值有 160 bits，大约 10<sup>48</sup> 个值，一个月球上大约有 10<sup>47</sup> 个原子，这样 40 位散列值大致可以表示 10 个月球的原子。</p>
</blockquote>

<h3 id="存储">存储</h3>
<p>简单地说，git 对象是存储成对象的有向无环图（DAG），它们都是压缩存储，用 40 个字符的 SHA-1 散列唯一标识（不是它们内容的 SHA-1 散列，而且它们在 git 中呈现内容的 SHA-1 散列）。</p>

<ul>
  <li>blob: 最简单的一种对象，就是一堆字符，通常就是一个文件，也可以是符号链接（symlink）或者类似的东西；</li>
  <li>tree: 文件夹通常用 tree 对象表示。一个 tree 会指向文件（也就是 blobs，包含文件名，访问方式等属性都存储在 tree 中，注意文件名没有存储在 blob 中而是储存在 tree 对象里，这样做对于重命名或者同一个文件多副本的情况都是有好处的）和子文件夹（其他的 tree 对象）。</li>
  <li>commit: 一个提交指向提交时所有文件状态的一个 tree，它也指向 0..n 个其他 commit 作为它的父节点。对于一个父节点的 commit 是一次 merge，没有父节点的是初始提交。commit 对象的 body 是 commit message.</li>
  <li>refs: References, or heads or branches 就像粘在 DAG 中节点上的便利贴。它们可以在节点上自由移动，它们状态变化不会存储在记录中，显示的是当前的状态。一般 refs 都在命名空间 heads/xxx 下，简写可以略掉 heads/。</li>
  <li>remote refs: 通过命名空间来区别于一般的 refs，它们一般是由远端的服务器来控制的，通过 git fetch 来更新它们。在图上会用另一种颜色来区别显示一般的 refs。</li>
  <li>tag: 它即是 DAG 中的一个节点，也是粘在上面的便利贴。tag 指向一个 commit，包含一个可选的消息以及一个 GPG 签名。tag 的便利贴属性是为了能快速定位，如果丢失了也能用命令 <code class="language-plaintext highlighter-rouge">git fsck --lost-found</code> 从 DAG 中恢复。</li>
</ul>

<p><img src="/assets/img/post/git-storage.6.dot.svg" alt="Git storage" title="git storage" /></p>

<p>git commit 操作会在 DAG 上新增一个节点，并将当前分支的便利贴指向这个最新的节点。HEAD ref 是一个特别的 ref， 它指向一个其他的 ref，一般指向当前分支。</p>

<p><img src="/assets/img/post/git-head-master.png" alt="Git HEAD 1" title="git HEAD" /></p>

<p><img src="/assets/img/post/git-head-after-commit.png" alt="Git HEAD 2" title="git HEAD after commit" /></p>

<p>当 HEAD 偶尔发生了没有指到某个分支的时候，就叫 detached HEAD，这种情况发生的原因有下面几个</p>

<ol>
  <li>使用 checkout 命令直接跳转到某个 commit，而那个 commit 刚好没有分支指着它；</li>
  <li>rebase 的过程其实也是不断处于 detached HEAD 的状态；</li>
  <li>切换到某个远端分支；</li>
</ol>

<p>DAG 中的节点能从一个仓库移动到另一个仓库，也能存储成一种更高效的形式（packs），未被使用的节点也用命令 <code class="language-plaintext highlighter-rouge">git gc</code> 回收。一个 git 仓库可以简单地理解为一个 DAG 和一堆便利贴。</p>

<h3 id="暂存区">暂存区</h3>

<p>Git 的工作目录中的文件主要分为下面几种状态</p>

<ul>
  <li>已知文件（已跟踪文件）
    <ul>
      <li>已提交文件（文件和上次提交比较未发生变化）</li>
      <li>已修改文件</li>
    </ul>
  </li>
  <li>未知文件
    <ul>
      <li>已忽略文件</li>
      <li>未跟踪文件</li>
    </ul>
  </li>
</ul>

<p>还有另一种状态，在使用 <code class="language-plaintext highlighter-rouge">git add</code> 命令后 git 会对其索引（index），存储将要提交信息的暂存区，索引是预期的下一次提交。这样上面的已修改文件和未跟踪文件都要再区分下是否已进入暂存区。</p>

<p><img src="/assets/img/post/git-index.png" alt="Git index" title="git index" /></p>

<h2 id="实战操作">实战操作</h2>

<p>这部分内容就是应用上面介绍的基础知识应用到具体的操作上，里面的内容主要来自 Stackoverflow 网友的回答。</p>

<h3 id="如何把一些提交从一个-git-仓库拷贝到另一个-git-仓库中">如何把一些提交从一个 Git 仓库拷贝到另一个 Git 仓库中</h3>

<p><a href="https://stackoverflow.com/questions/37471740/how-to-copy-commits-from-one-git-repo-to-another">How to copy commits from one Git repo to another?</a></p>

<p>在新仓库中添加远程仓库的地址，然后挑选出远程仓库需要的提交在新仓库中重播，步骤代码如下</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1"><span class="c"># add the old repo as a remote repository</span>
</div><div class="line-2">git remote add oldrepo https://github.com/path/to/oldrepo
</div><div class="line-3">
</div><div class="line-4"><span class="c"># get the old repo commits</span>
</div><div class="line-5">git remote update
</div><div class="line-6">
</div><div class="line-7"><span class="c"># examine the whole tree</span>
</div><div class="line-8">git log <span class="nt">--all</span> <span class="nt">--oneline</span> <span class="nt">--graph</span> <span class="nt">--decorate</span>
</div><div class="line-9">
</div><div class="line-10"><span class="c"># copy (cherry-pick) the commits from the old repo into your new local one</span>
</div><div class="line-11">git cherry-pick sha-of-commit-one
</div><div class="line-12">git cherry-pick sha-of-commit-two
</div><div class="line-13">git cherry-pick sha-of-commit-three
</div><div class="line-14">
</div><div class="line-15"><span class="c"># check your local repo is correct</span>
</div><div class="line-16">git log
</div><div class="line-17">
</div><div class="line-18"><span class="c"># remove the now-unneeded reference to oldrepo</span>
</div><div class="line-19">git remote remove oldrepo
</div></code></pre></figure>

<h3 id="如何合并提交">如何合并提交</h3>
<p><a href="https://stackoverflow.com/questions/2563632/how-can-i-merge-two-commits-into-one-if-i-already-started-rebase">How can I merge two commits into one if I already started rebase?</a></p>

<p><a href="https://gitready.com/advanced/2009/02/10/squashing-commits-with-rebase.html">squashing commits with rebase</a></p>

<p>假设 git 的历史如下，c 是最近一次提交，a 是较早的一次提交，我们想把 b 和 c 合并成一个提交，最后只留下 a 和 bc 两个提交。</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1">git log <span class="nt">-n</span> 3 <span class="nt">--pretty</span><span class="o">=</span>oneline
</div><div class="line-2">b64ec63ade24acf985972549e9a6e756a887cd13 c
</div><div class="line-3">e993be87563a6f7b23251d56df0410e38c530e4e b
</div><div class="line-4">b109737d9e52538129fb50b3263bae594120c008 a
</div></code></pre></figure>

<p>可以使用 rebase 的交互模式（<code class="language-plaintext highlighter-rouge">--interactive</code> 或者 <code class="language-plaintext highlighter-rouge">-i</code>），<code class="language-plaintext highlighter-rouge">git rebase --interactive HEAD~2</code> 会进入如下编辑模式，里面包含了很清晰的解释，注意此处提交的顺序和上面不同，是最早的提交记录在上面。</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1">pick e993be8 b
</div><div class="line-2">pick b64ec63 c
</div><div class="line-3">
</div><div class="line-4"><span class="c"># Rebase b109737..b64ec63 onto b109737 (2 commands)</span>
</div><div class="line-5"><span class="c">#</span>
</div><div class="line-6"><span class="c"># Commands:</span>
</div><div class="line-7"><span class="c"># p, pick &lt;commit&gt; = use commit</span>
</div><div class="line-8"><span class="c"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span>
</div><div class="line-9"><span class="c"># e, edit &lt;commit&gt; = use commit, but stop for amending</span>
</div><div class="line-10"><span class="c"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span>
</div><div class="line-11"><span class="c"># f, fixup &lt;commit&gt; = like "squash", but discard this commit's log message</span>
</div><div class="line-12"><span class="c"># x, exec &lt;command&gt; = run command (the rest of the line) using shell</span>
</div><div class="line-13"><span class="c"># b, break = stop here (continue rebase later with 'git rebase --continue')</span>
</div><div class="line-14"><span class="c"># d, drop &lt;commit&gt; = remove commit</span>
</div><div class="line-15"><span class="c"># l, label &lt;label&gt; = label current HEAD with a name</span>
</div><div class="line-16"><span class="c"># t, reset &lt;label&gt; = reset HEAD to a label</span>
</div><div class="line-17"><span class="c"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span>
</div><div class="line-18"><span class="c"># .       create a merge commit using the original merge commit's</span>
</div><div class="line-19"><span class="c"># .       message (or the oneline, if no original merge commit was</span>
</div><div class="line-20"><span class="c"># .       specified). Use -c &lt;commit&gt; to reword the commit message.</span>
</div><div class="line-21"><span class="c">#</span>
</div><div class="line-22"><span class="c"># These lines can be re-ordered; they are executed from top to bottom.</span>
</div><div class="line-23"><span class="c">#</span>
</div><div class="line-24"><span class="c"># If you remove a line here THAT COMMIT WILL BE LOST.</span>
</div><div class="line-25"><span class="c">#</span>
</div><div class="line-26"><span class="c"># However, if you remove everything, the rebase will be aborted.</span>
</div><div class="line-27"><span class="c">#</span>
</div></code></pre></figure>

<p>把上面第二行的提交 c 前面的 <code class="language-plaintext highlighter-rouge">pick</code> 改成 <code class="language-plaintext highlighter-rouge">squash</code>，也即把新的提交压入上一次提交中，”squashing upward”。</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1">pick e993be8 b
</div><div class="line-2">squash b64ec63 c
</div></code></pre></figure>

<p>修改如上，保存后会进入合并提交消息的编辑窗口，修改后保存即可。</p>

<h3 id="如何在仓库中删除某位作者的所有提交">如何在仓库中删除某位作者的所有提交</h3>
<p><a href="https://stackoverflow.com/questions/39232800/remove-all-commits-by-author">Remove all commits by author</a></p>

<p>基本思想是挑选出需要的提交，在新的分支上重播一遍。</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><div class="line-1"><span class="c"># 从某个节点开始创建新分支</span>
</div><div class="line-2">git checkout <span class="nt">-b</span> &lt;branch-name&gt; &lt;base-commit&gt;
</div><div class="line-3">
</div><div class="line-4"><span class="c"># 从 master 分支中挑选出提交并在当前分支上重播</span>
</div><div class="line-5"><span class="c"># --author "&lt;name&gt;" 过滤出作者，如果过滤 committer 用参数 --committer</span>
</div><div class="line-6"><span class="c"># --invert-grep 反选上面的筛选结果，在此处即选出非指定作者的提交</span>
</div><div class="line-7"><span class="c"># --reverse 结果用逆向排序，即满足条件的最早提交在第一行</span>
</div><div class="line-8"><span class="c"># --format="format:%H" 指定只显示 commit hash 值</span>
</div><div class="line-9">git log <span class="nt">--author</span> <span class="s2">"&lt;name&gt;"</span> <span class="nt">--invert-grep</span> <span class="nt">--reverse</span> <span class="nt">--format</span><span class="o">=</span><span class="s2">"format:%H"</span> HEAD..master | xargs git cherry-pick
</div></code></pre></figure>

<h2 id="参考链接">参考链接</h2>
<p><a href="https://git-scm.com/book/zh/v2">Pro Git</a></p>

<p><a href="https://git-scm.com/docs">Git Reference</a></p>

<p><a href="https://www.linuxfoundation.org/blog/10-years-of-git-an-interview-with-git-creator-linus-torvalds/">10 Years of Git: An Interview with Git Creator Linus Torvalds</a></p>

<p><a href="https://eagain.net/articles/git-for-computer-scientists/">Git for Computer Scientists</a></p>

<p><a href="https://github.com/github/gitignore">A collection of .gitignore templates</a></p>

<p><a href="https://stackoverflow.com/questions/215718/how-can-i-reset-or-revert-a-file-to-a-specific-revision">How can I reset or revert a file to a specific revision?</a></p>

<p><a href="https://stackoverflow.com/questions/1057564/pretty-git-branch-graphs">Pretty Git branch graphs</a></p>

<p><a href="https://gitbook.tw/chapters/faq/detached-head">【冷知識】斷頭（detached HEAD）是怎麼一回事？</a></p>

<p><a href="https://gitbook.tw/chapters/branch/merge-with-rebase">另一種合併方式（使用 rebase）</a></p>

<p><a href="https://stackoverflow.com/questions/1274057/how-can-i-make-git-forget-about-a-file-that-was-tracked-but-is-now-in-gitign">How can I make Git “forget” about a file that was tracked, but is now in .gitignore?</a></p>

<p><a href="https://learngitbranching.js.org">学习 Git 网页版进阶教程</a></p>

        </div>

        
<div class="comments" id="comments">
	<div id="disqus_thread"></div>
	<script type="text/javascript">

	    var disqus_shortname = 'https-algony-tony-github-io';

	    (function() {
	        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	    })();

	</script>
	<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>


      </div>

      
      <div class="right">
    <div class="side-wrap">
        <!-- Content -->
        <nav class="side-content">
            <ul id="content-side" class="content-ul">
                <li><a href="#comments">评论区</a></li>
            </ul>
        </nav>
    </div>
</div>

<script src="/assets/js/postContent.js" charset="utf-8"></script>
      

      

    </article>

  </div>
</main>

    
      <footer class="site-footer">

  <div class="wrapper-footer">
    <div class="social-wrapper">
      







<a href="/feed.xml"><i class="svg-icon rss"></i></a>




    </div>

    <div>
      <p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
    </div>

    <div>Site powered by <a href="https://jekyllrb.com/">Jekyll</a> & <a href="https://pages.github.com/">Github Pages</a>.</div>
  </div>

</footer>

    

  </body>
</html>

